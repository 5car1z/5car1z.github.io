<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content="Linux System Administration"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="atom.xml" title="Tricks of the Trades" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Virtualisation - Tricks of the Trades</title><link rel="stylesheet" href="/css/main.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"><a href="/">Tricks of the Trades</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Home</a></li><li class="head-nav__item"><a href="/trades" class="head-nav__link">Trades</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archives</a></li><li class="head-nav__item"><a href="/work" class="head-nav__link">Work</a></li><li class="head-nav__item"><a href="/about" class="head-nav__link">About</a></li><li class="head-nav__item"><a href="/contact" class="head-nav__link">Contact</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2017-05-16T23:00:00.000Z" class="post__time">May 17, 2017</time><h1 class="post__title"><a href="/2017/05/17/vagrant-started/">How to Install and Get Started with Vagrant in 2017</a></h1></header><div class="post__main echo"><p><img src="https://i.imgur.com/mw4s7ic.png" alt="Vagrant Logo"></p>
<h1 id="Preamble"><a href="#Preamble" class="headerlink" title="Preamble"></a>Preamble</h1><p>Despite its age and familiarity to most nowadays I couldn’t find a straight forward post on how to install and get started using Vagrant. So here’s my notes on doing so in blog post format. Be aware that this is well trodden ground and the Vagrant documentation on their website has a similar set of steps and content. The official site, if not this will get you where you need to be when it comes to getting started with Vagrant. </p>
<blockquote>
<p><a href="https://www.vagrantup.com/intro/getting-started/index.html" target="_blank" rel="external">Official Vagrant Website - Getting Started</a></p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="1-–-Install-VirtualBox"><a href="#1-–-Install-VirtualBox" class="headerlink" title="1 – Install VirtualBox"></a>1 – Install VirtualBox</h1><p>Our provider choice will be VirtualBox. The <em>provider</em> describes the software in charge of creating then managing the virtual machines comissioned by Vagrant. The two major providers are VirtualBox and VMware, VirtualBox is free and open source, whereas VMware is not. </p>
<p><a href="https://www.virtualbox.org/wiki/Linux_Downloads" target="_blank" rel="external">Find the correct installation procedure for your flavour of Linux here.</a></p>
<p>On Ubuntu you would add this line to the bottom of your <code>sources.list</code> file:</p>
<p><code>deb http://download.virtualbox.org/virtualbox/debian xenial contrib</code></p>
<p>Replacing <code>xenial</code> for your own distributions release codename. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>You can find this codename if you don’t already know it by running this command; back on the prompt. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release <span class="_">-a</span></span><br></pre></td></tr></table></figure>
<p>For Debian 8 (“Jessie”) and Ubuntu 16.04 (“Xenial”) or later distributions. Download and add the repositories PGP key. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>Update the apt-get package database and install the <code>virtualbox</code> packages. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install virtualbox</span><br></pre></td></tr></table></figure>
<p>VirtualBox is now installed and ready to use. </p>
<hr>
<h1 id="2-–-Install-Vagrant"><a href="#2-–-Install-Vagrant" class="headerlink" title="2 – Install Vagrant"></a>2 – Install Vagrant</h1><p><a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">Find the correct binary for your version of Linux, then download it with the URL and Wget.</a></p>
<p>Here’s the <code>wget</code> command and correct URL for downloading the latest version of Vagrant on Debian (at the time of writing this) - yours may differ. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://releases.hashicorp.com/vagrant/1.9.4/vagrant_1.9.4_x86_64.deb ~</span><br></pre></td></tr></table></figure>
<p>To then install the binary as a package on the system, use:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -i vagrant_1.9.4_x86_64.deb</span><br></pre></td></tr></table></figure>
<p>You can remove the Vagrant <code>.deb</code> build file from your user’s home directory now, after it’s been installed. </p>
<hr>
<h2 id="3-–-Download-and-Use-a-Vagrant-Box"><a href="#3-–-Download-and-Use-a-Vagrant-Box" class="headerlink" title="3 – Download and Use a Vagrant Box"></a>3 – Download and Use a Vagrant Box</h2><p>Make a temporary test directory, and change into it, before continuing. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/vagrant-test &amp;&amp; <span class="built_in">cd</span> vagrant-test</span><br></pre></td></tr></table></figure>
<p>To test the install, you can download and run a basic Vagrant box as a VM by running the next set of commands.</p>
<p>So we’re clear, here’s a good definition of a what a Vagrant “box” actually is: </p>
<blockquote>
<p>“A package containing a representation of a virtual machine running a specific operating system. To be more simple, it is a base image of any Operating System or Kernel. It may be for a specific Provider.”</p>
</blockquote>
<p>The box is the image, and from this image a virtual machine (VM) is created on the localhost. </p>
<p>The basic Vagrant configuration for this VM will be based in one file, the <code>Vagrantfile</code>. </p>
<p>This file is placed in the <code>~/vagrant-test</code> directory via:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant init ubuntu/xenial64</span><br></pre></td></tr></table></figure>
<p>There are a wide variety of different box types (various OS images) listed on <a href="https://atlas.hashicorp.com/boxes/search" target="_blank" rel="external">Hashi corp’s  Atlas index.</a></p>
<p>After issuing the next command Vagrant will start to download the box and attempt to create and run a VM through VirtualBox.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure>
<p>Here’s an example of what the progress output looks like for this:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">==&gt; default: Box <span class="string">'ubuntu/xenial64'</span> could not be found. Attempting to find and install...</span><br><span class="line">    default: Box Provider: virtualbox</span><br><span class="line">    default: Box Version: &gt;= 0</span><br><span class="line">==&gt; default: Loading metadata <span class="keyword">for</span> box <span class="string">'ubuntu/xenial64'</span></span><br><span class="line">    default: URL: https://atlas.hashicorp.com/ubuntu/xenial64</span><br><span class="line">==&gt; default: Adding box <span class="string">'ubuntu/xenial64'</span> (v2017.05.01) <span class="keyword">for</span> provider: virtualbox</span><br><span class="line">    default: Downloading: https://vagrantcloud.com/ogarcia/boxes/archlinux-x32/versions/2017.05.01/providers/virtualbox.box</span><br><span class="line">==&gt; default: Successfully added box <span class="string">'ubuntu/xenial64'</span> (v2017.05.01) <span class="keyword">for</span> <span class="string">'virtualbox'</span>!</span><br><span class="line">==&gt; default: Importing base box <span class="string">'ubuntu/xenial64'</span>...</span><br><span class="line">==&gt; default: Matching MAC address <span class="keyword">for</span> NAT networking...</span><br><span class="line">==&gt; default: Checking <span class="keyword">if</span> box <span class="string">'ubuntu/xenial64'</span> is up to date...</span><br><span class="line">==&gt; default: Setting the name of the VM: vagrant-testing_default_1494195673719_66642</span><br><span class="line">==&gt; default: Clearing any previously <span class="built_in">set</span> network interfaces...</span><br><span class="line">==&gt; default: Preparing network interfaces based on configuration...</span><br><span class="line">    default: Adapter 1: nat</span><br><span class="line">==&gt; default: Forwarding ports...</span><br><span class="line">    default: 22 (guest) =&gt; 2222 (host) (adapter 1)</span><br><span class="line">==&gt; default: Booting VM...</span><br><span class="line">==&gt; default: Waiting <span class="keyword">for</span> machine to boot. This may take a few minutes...</span><br><span class="line">    default: SSH address: 127.0.0.1:2222</span><br><span class="line">    default: SSH username: vagrant</span><br><span class="line">    default: SSH auth method: private key</span><br><span class="line">    default: </span><br><span class="line">    default: Vagrant insecure key detected. Vagrant will automatically replace</span><br><span class="line">    default: this with a newly generated keypair <span class="keyword">for</span> better security.</span><br><span class="line">    default: </span><br><span class="line">    default: Inserting generated public key within guest...</span><br><span class="line">    default: Removing insecure key from the guest <span class="keyword">if</span> it<span class="string">'s present...</span><br><span class="line">    default: Key inserted! Disconnecting and reconnecting using new SSH key...</span><br><span class="line">==&gt; default: Machine booted and ready!</span><br><span class="line">==&gt; default: Checking for guest additions in VM...</span><br><span class="line">    default: The guest additions on this VM do not match the installed version of</span><br><span class="line">    default: VirtualBox! In most cases this is fine, but in rare cases it can</span><br><span class="line">    default: prevent things such as shared folders from working properly. If you see</span><br><span class="line">    default: shared folder errors, please make sure the guest additions within the</span><br><span class="line">    default: virtual machine match the version of VirtualBox you have installed on</span><br><span class="line">    default: your host and reload your VM.</span><br><span class="line">    default: </span><br><span class="line">    default: Guest Additions Version: 5.1.22 r115126</span><br><span class="line">    default: VirtualBox Version: 5.0</span><br><span class="line">==&gt; default: Mounting shared folders...</span><br><span class="line">    default: /vagrant =&gt; /home/scarlz/vagrant-testing</span></span><br></pre></td></tr></table></figure>
<p>You can get an error message here relating to CPU architecture if you use a box that isn’t intended for your host’s operating system.</p>
<p>For example, the first image here requires a 64-bit host operating system, and then the second is for a 32-bit version. The “host” here refers to the machine you installed Vagrant on.</p>
<ul>
<li><a href="https://atlas.hashicorp.com/ubuntu/boxes/xenial64" target="_blank" rel="external">https://atlas.hashicorp.com/ubuntu/boxes/xenial64</a></li>
<li><a href="https://atlas.hashicorp.com/ubuntu/boxes/trusty32" target="_blank" rel="external">https://atlas.hashicorp.com/ubuntu/boxes/trusty32</a></li>
</ul>
<p>In my example we used the first box, a 64-bit system. </p>
<p>Also if you are running Vagrant itself in a virtual machine (using a hypervisor). Then you’ll need to ensure your hypervisor has “VT-x/AMD-V enabled”.</p>
<p>To enable this you’ll have to do something along the lines of:</p>
<ol>
<li>Power off the host virtual machine.</li>
<li>Edit the individual virtual machine’s settings.</li>
<li>Go to the CPU/processors section.</li>
<li>Enable “VT-x/AMD-V” /  “Virtualise Intel VR-x/EPT and AMD-V/RVI”</li>
<li>Then power on the virtual machine again.</li>
<li>Re-run <code>vagrant up</code> in your Vagrant testing directory.</li>
</ol>
<p>Here is what the setting looks like when using VMware Workstation as your hypervisor.</p>
<p><img src="https://i.gyazo.com/2f12d720498b753e09eb79f6f31117c9.png" alt="Vmware CPU Section Image"></p>
<hr>
<h1 id="4-–-Connect-to-a-Running-VM"><a href="#4-–-Connect-to-a-Running-VM" class="headerlink" title="4 – Connect to a Running VM"></a>4 – Connect to a Running VM</h1><p>Once a box is installed and configured to run in a VM (like in step 2), you connect to the VM through an SSH tunnel created by Vagrant. </p>
<p>To connect to the newly running VM with Vagrant use:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh</span><br></pre></td></tr></table></figure>
<p>The prompt now shows you are connected to your new VM!</p>
<figure class="highlight bash"><figcaption><span>prompt example</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-xenial:~$</span><br></pre></td></tr></table></figure>
<p>Type <code>exit</code> or use <code>CTRL + D</code> to leave the VM’s command line and return to your host. </p>
<hr>
<h1 id="5-–-Vagrant-Sub-commands"><a href="#5-–-Vagrant-Sub-commands" class="headerlink" title="5 – Vagrant Sub-commands"></a>5 – Vagrant Sub-commands</h1><p>These are the commands you’ll find yourself using when working with Vagrant. They use subsets of subcommands - which may seem confusing at first glance. The first is <code>box</code> and has several susbets. Not all however have them.</p>
<h2 id="box"><a href="#box" class="headerlink" title="box"></a><a href="https://www.vagrantup.com/docs/cli/box.html" target="_blank" rel="external">box</a></h2><p>List all the boxes you currently have installed on the host. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box list</span><br></pre></td></tr></table></figure>
<p>Remove an already existing box from Vagrant. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box remove ubuntu/xenial64</span><br></pre></td></tr></table></figure>
<p>Check updates for all box images on your system. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box update</span><br></pre></td></tr></table></figure>
<p>Many of these commands can have the box named appended to them. In order to single them out. </p>
<h2 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a><a href="https://www.vagrantup.com/docs/cli/destroy.html" target="_blank" rel="external">destroy</a></h2><p>The Vagrant documentation sums this command up pretty well:</p>
<blockquote>
<p>“This command stops the running machine Vagrant is managing and destroys all resources that were created during the machine creation process. After running this command, your computer should be left at a clean state, as if you never created the guest machine in the first place.”</p>
</blockquote>
<p>Use it to destroy your created virual machines e.g.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant destroy ubuntu/xenial64</span><br></pre></td></tr></table></figure>
<h2 id="halt"><a href="#halt" class="headerlink" title="halt"></a><a href="https://www.vagrantup.com/docs/cli/halt.html" target="_blank" rel="external">halt</a></h2><p>This command shuts down the running virtual machine Vagrant is currently managing; you can add a machine name/ID to target specific VM’s</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant halt</span><br></pre></td></tr></table></figure>
<h2 id="reload"><a href="#reload" class="headerlink" title="reload"></a><a href="https://www.vagrantup.com/docs/cli/reload.html" target="_blank" rel="external">reload</a></h2><p>This is the same as a <code>vagrant halt</code> but restarts the VM after halting - like with <code>vagrant up</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant reload</span><br></pre></td></tr></table></figure>
<h2 id="port"><a href="#port" class="headerlink" title="port"></a><a href="https://www.vagrantup.com/docs/cli/port.html" target="_blank" rel="external">port</a></h2><p>This allows you to list all the Vagrant guest ports that are mapped to the host ports. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant port</span><br></pre></td></tr></table></figure>
<h2 id="ssh-config"><a href="#ssh-config" class="headerlink" title="ssh_config"></a><a href="https://www.vagrantup.com/docs/cli/ssh_config.html" target="_blank" rel="external">ssh_config</a></h2><p>Useful for displaying the output of the Vagrant host side SSH configuration file. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh-config</span><br></pre></td></tr></table></figure>
<p>Returns:</p>
<figure class="highlight bash"><figcaption><span>Example Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host default</span><br><span class="line">  HostName 127.0.0.1</span><br><span class="line">  User ubuntu</span><br><span class="line">  Port 2222</span><br><span class="line">  UserKnownHostsFile /dev/null</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  PasswordAuthentication no</span><br><span class="line">  IdentityFile /home/scarlz/vagrant-ubuntu-test/.vagrant/machines/default/virtualbox/private_key</span><br><span class="line">  IdentitiesOnly yes</span><br><span class="line">  LogLevel FATAL</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-–-Miscellaneous"><a href="#6-–-Miscellaneous" class="headerlink" title="6 – Miscellaneous"></a>6 – Miscellaneous</h2><p>Should there ever be any SSH connection issues to a VM. The connection log can be seen by appending <code>--debug</code> to the command. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh --debug</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong> This <code>--debug</code> flag can be added onto most Vagrant commands to see the internal operations being carried out. </p>
</blockquote>
<p>Checking the status of the current Vagrant virtual machine is possible by entering:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant status</span><br></pre></td></tr></table></figure>
<p>A global version also exists.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant global-status</span><br></pre></td></tr></table></figure>
<p>Adding the <code>--prune</code> flag updates the cache for this - thereby removing any old, dead entries from the output. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant global-status --prune</span><br></pre></td></tr></table></figure>
<p>Looking back to the <code>Vagrantfile</code> configuration. We can see that there are different options on offer to configure the resultant VM(s). </p>
<p>One to highlight is the VM name that is assigned to both the provider (VirtualBox) and internal Vagrant machine “name”. </p>
<p>This is the code to explicitly define it in both instances, if you ever want to:</p>
<figure class="highlight bash"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(VAGRANTFILE_API_VERSION) <span class="keyword">do</span> |config|</span><br><span class="line"></span><br><span class="line"> config.vm.define <span class="string">"ubuntu_test_vm"</span> <span class="keyword">do</span> |vmname|</span><br><span class="line"> end</span><br><span class="line">  </span><br><span class="line"> config.vm.provider :virtualbox <span class="keyword">do</span> |vb|</span><br><span class="line">     vb.name = <span class="string">"ubuntu_test_vm"</span></span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>Line 3 determines the <code>&quot;name&quot;</code> listed when issuing: <code>vagrant global-status</code></p>
<p>Whilst line 5/6 ensures VirtualBox names and displays the VM properly in its GUI. </p>
<p><img src="https://i.imgur.com/CrSEOo4.png" alt="VirtualBox Ubuntu VM Image"></p>
<p><a href="https://www.vagrantup.com/docs/vagrantfile/" target="_blank" rel="external">How the Vagrantfile works in terms of configuration is described in detail here.</a></p>
<hr>
<h2 id="7-–-Autocompletion"><a href="#7-–-Autocompletion" class="headerlink" title="7 – Autocompletion"></a>7 – Autocompletion</h2><p>A nice addition to Vagrant is shell auto completion (Bash shell) for when typing in the above commands.  An up to date (at the time of writing this) repo which provides this is located here: </p>
<blockquote>
<p><a href="https://github.com/brbsix/vagrant-bash-completion" target="_blank" rel="external">https://github.com/brbsix/vagrant-bash-completion</a></p>
</blockquote>
<p>This is a fork of <a href="https://github.com/kura/vagrant-bash-completion" target="_blank" rel="external">Kura’s old repo</a>; thanks go to him for maintaining this up until now. Here’s the provided “easiest” method of downloading this functionality to your Linux/Unix host system. </p>
<p><code>wget</code> the script file in the above repo. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -q https://raw.github.com/brbsix/vagrant-bash-completion/master/vagrant-bash-completion/etc/bash_completion.d/vagrant</span><br></pre></td></tr></table></figure>
<p>Add the newly downloaded file to the system Bash completion directory - whilst modifying the file’s permissions. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo install -m 0644 vagrant /etc/bash_completion.d/</span><br></pre></td></tr></table></figure>
<p>Now either close and re-open your terminal, or <code>source</code> in the new <code>/etc/bash_completion.d/vagrant</code> bash completion file. To get the new auto-completion working. </p>
<hr>
<h1 id="8-–-Further-Reading"><a href="#8-–-Further-Reading" class="headerlink" title="8 – Further Reading"></a>8 – Further Reading</h1><p>Erika Heidi has recently revisited and updated her great in-depth book dedicated to Vagrant. For a full run down of Vagrant and how to add configuration management tools into the mix. I’d highly recommend this book. </p>
<p><img src="https://i.imgur.com/0kT5WIB.png" alt="Cookbook - Frontcover"></p>
<blockquote>
<p><a href="https://leanpub.com/vagrantcookbook" target="_blank" rel="external">https://leanpub.com/vagrantcookbook</a></p>
</blockquote>
<p>There’s an accompanying blog post from February 2017 that she’s put together on recent Vagrant usage and trends. It’s quite short and worth reading if you’re interested.</p>
<blockquote>
<p><a href="http://www.erikaheidi.com/blog/vagrant-usage-research-2017/" target="_blank" rel="external">http://www.erikaheidi.com/blog/vagrant-usage-research-2017/</a></p>
</blockquote>
<p>The infographic (which I’ll leave here) is the main takeaway from the post:</p>
<p><img src="http://www.erikaheidi.com/files/2017-02/vagrant-research-2017.png" alt="The State of Vagrant Infographic"></p>
<hr>
<p>Vagrant is a slightly ageing software in the sense that many prefer more recent tools like Docker. It does however still have its uses and is quite well adopted these days, so it’s more than worth understanding at least the basics.</p>
<p>Enjoy your time with Vagrant.  </p>
<hr>
<p><strong>More Information</strong></p>
<ul>
<li><a href="https://stackoverflow.com/questions/17175696/running-vagrant-inside-vmware-vm" target="_blank" rel="external">Stack Overflow - Running Vagrant Inside VMWare VM</a> – As mentioned in step 2. </li>
<li><a href="https://stackoverflow.com/questions/22922891/vagrant-ssh-authentication-failure" target="_blank" rel="external">Stack Overflow - Vagrant ssh authentication failure</a> – An issue that seems to occur with the official Vagrant Ubuntu images. </li>
<li><a href="https://stackoverflow.com/questions/17845637/how-to-change-vagrant-default-machine-name" target="_blank" rel="external">Stack Overflow - How to change Vagrant ‘default’ machine name?</a> – Complex but comprehensive thread for this. </li>
<li><a href="https://stackoverflow.com/questions/24440142/removing-list-of-vms-in-vagrant-cache" target="_blank" rel="external">Stack Overflow - Removing list of vms in vagrant cache</a> – For when the status output is not accurate/updating. </li>
<li><a href="https://github.com/mitchellh/vagrant/issues/5186" target="_blank" rel="external">“Warning: Authentication failure. Retrying…”</a> – A very detailed long-term GitHub thread detailing the aforementioned issue. </li>
</ul>
<blockquote>
<p>Easily deploy an SSD cloud server on <a href="https://www.digitalocean.com/?refcode=e91058dbfc7b" target="_blank" rel="external">Digital Ocean</a> in 55 seconds. Sign up using my link and receive $10.00 in free credit: <a href="https://www.digitalocean.com/?refcode=e91058dbfc7b" target="_blank" rel="external">https://www.digitalocean.com/?refcode=e91058dbfc7b</a></p>
</blockquote>
<p>– Scarlz: <a href="https://twitter.com/5car1z" target="_blank" rel="external">@5car1z</a></p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/Ubuntu/" class="post__tag__link">Ubuntu</a></li><li class="post__tag__item"><a href="/tags/Virtualisation/" class="post__tag__link">Virtualisation</a></li><li class="post__tag__item"><a href="/tags/Vagrant/" class="post__tag__link">Vagrant</a></li></ul><a href="/2017/05/17/vagrant-started/#disqus_thread" class="post__foot-link u-fr">COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2016-05-17T23:00:00.000Z" class="post__time">May 18, 2016</time><h1 class="post__title"><a href="/2016/05/18/docker-images-hub/">Docker - Building Images and Docker Hub (5)</a></h1></header><div class="post__main echo"><p><img src="http://i.imgur.com/poo8Rai.png" alt="Docker Logo"></p>
<h1 id="Preamble"><a href="#Preamble" class="headerlink" title="Preamble"></a>Preamble</h1><p>Docker images can be thought of as blueprints and house the software or files required to run your application inside of a container. So far in these Docker posts all container images have been pulled from an online source and no real interaction with the images themselves has been explored. </p>
<p>However in this post we’re taking a very simple Python Flask application and going through the process of <em>dockerising</em> it. Which in non-jargon terms means we are configuring and creating our own custom Docker image, to then run it in a container like any other image. This usually also involves uploading it to Docker Hub for others to pull down and use, so is covered in the guide. </p>
<p>The <a href="http://www.tricksofthetrades.net/2016/03/14/docker-data-volumes/">Docker - Data Volumes and Data Containers (4)</a> post that comes before this one is mostly unrelated so not really a requirement for this post, but still worth checking out overall. </p>
<a id="more"></a>
<hr>
<h1 id="1-–-Clone-the-Repository"><a href="#1-–-Clone-the-Repository" class="headerlink" title="1 –  Clone the Repository"></a>1 –  Clone the Repository</h1><p>The example application used in this post is named “Flaskr” and serves as a very simple messaging board. It allows a user to sign in/out, add new written entries to the message board displayed, and does all this using SQLite as the database backend. </p>
<p>Clone this example application and its code locally. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/5car1z/docker-flaskr.git ~/docker-flaskr</span><br></pre></td></tr></table></figure>
<p>Change your working directory to the new repository.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/docker-flaskr</span><br></pre></td></tr></table></figure>
<p>Take a quick glance at the files using:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br></pre></td></tr></table></figure>
<p>Which returns: </p>
<figure class="highlight bash"><figcaption><span>Output </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flaskr.py  flaskr_settings  README  requirements.txt  schema.sql  static  templates  test_flaskr.py</span><br></pre></td></tr></table></figure>
<p>Then move onto the next step. </p>
<hr>
<h1 id="2-–-Configure-the-Application"><a href="#2-–-Configure-the-Application" class="headerlink" title="2 –  Configure the Application"></a>2 –  Configure the Application</h1><p>Most Flask or Python projects contain a file that holds circumstantial configuration values. These settings differ from user to user and when running the application in development/production environments. To run our Flaskr application and build a successful Docker image later on, we must set the values in this file beforehand.  </p>
<p>Open the <code>flaskr_settings</code> file with your preferred text editor.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim flaskr_settings</span><br></pre></td></tr></table></figure>
<p>The first two lines containing the database file location and debug status should remain as they are. There is no need to change these for this scenario. </p>
<figure class="highlight bash"><figcaption><span>flaskr_settings</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># configuration</span></span><br><span class="line">DATABASE = <span class="string">'flaskr.db'</span></span><br><span class="line">DEBUG = False</span><br></pre></td></tr></table></figure>
<p>Generating a secret key for the third line here is easiest using a Python console.</p>
<figure class="highlight bash"><figcaption><span>flaskr_settings</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECRET_KEY = <span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>Back on the command line outside of the editor run:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br></pre></td></tr></table></figure>
<p>Import the OS module. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>
<p>Run the associated OS function for generating a string of random bytes (urandom). </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.urandom(<span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>A 24 byte value is returned as output for use as the secret key in the <code>flaskr_settings</code> file. The key value shown here is for demonstration purposes only. </p>
<figure class="highlight python"><figcaption><span>Example Key Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\xebqD\x0f\xf3\xcf\xaa\x9e]%\x86\xd7\x11h\x8f\xa3\xa6\xbb=\xf7m\xf2&#123;\xfd'</span></span><br></pre></td></tr></table></figure>
<p>Copy your own secret key value into the third line of the <code>flaskr_settings</code> file - you can exit the Python console by pressing <code>CTRL</code> + <code>D</code> once the key has been retained. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim flaskr_settings</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><figcaption><span>flaskr_settings</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECRET_KEY = <span class="string">'\xebqD\x0f\xf3\xcf\xaa\x9e]%\x86\xd7\x11h\x8f\xa3\xa6\xbb=\xf7m\xf2&#123;\xfd'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong> Only one set of enclosing apostrophes are required: <code>&#39;&#39;</code> </p>
</blockquote>
<p>On the last two lines of the configuration file provide a username and password. These details are used for authentication when logging into the app after it is up and running. </p>
<p>Add in your own values. </p>
<figure class="highlight python"><figcaption><span>flaskr_settings</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USERNAME = <span class="string">'username'</span></span><br><span class="line">PASSWORD = <span class="string">'password'</span></span><br></pre></td></tr></table></figure>
<p>Save your changes to the <code>flaskr_settings</code> file before continuing, and exit the file. </p>
<p>My example entries and file look like this when completed:</p>
<figure class="highlight python"><figcaption><span>flaskr_settings</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># configuration</span></span><br><span class="line">DATABASE = <span class="string">'flaskr.db'</span></span><br><span class="line">DEBUG = <span class="keyword">False</span></span><br><span class="line">SECRET_KEY = <span class="string">'\xebqD\x0f\xf3\xcf\xaa\x9e]%\x86\xd7\x11h\x8f\xa3\xa6\xbb=\xf7m\xf2&#123;\xfd'</span></span><br><span class="line">USERNAME = <span class="string">'scarlz'</span></span><br><span class="line">PASSWORD = <span class="string">'password'</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-–-Create-the-Dockerfile"><a href="#3-–-Create-the-Dockerfile" class="headerlink" title="3 –  Create the Dockerfile"></a>3 –  Create the Dockerfile</h1><p>The build process and configuration parameters for our eventual Docker image get defined in a new file named the “Dockerfile”. </p>
<p>Create the new Dockerfile using your text editor again, and place each of the upcoming actions on its own separate line. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim Dockerfile</span><br></pre></td></tr></table></figure>
<p>Tell Docker to use the official Python 2.7 image as a base for our own custom image, on the first line.</p>
<figure class="highlight bash"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM python:2.7</span><br></pre></td></tr></table></figure>
<p>Define an environment variable that tells Flaskr the name of the configuration file we completed earlier.</p>
<figure class="highlight bash"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV FLASKR_SETTINGS flaskr_settings</span><br></pre></td></tr></table></figure>
<p>Add the <code>requirements.txt</code> file to the file-system of the image we are creating. </p>
<figure class="highlight bash"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD requirements.txt /tmp/requirements.txt</span><br></pre></td></tr></table></figure>
<p>Install the Flaskr application dependencies onto this image - sourced in from the “requirements” file. </p>
<figure class="highlight bash"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN pip install -r /tmp/requirements.txt</span><br></pre></td></tr></table></figure>
<p>Add the current working directory <code>.</code> of the project and its contents to a new directory on the image’s file-system. </p>
<figure class="highlight bash"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD . /flask-application</span><br></pre></td></tr></table></figure>
<p>Set the image’s file-system current working directory to the one we are creating. </p>
<figure class="highlight bash"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /flask-application</span><br></pre></td></tr></table></figure>
<p>Open port <code>5000</code> on the container so we can map it to a host port later. </p>
<figure class="highlight bash"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 5000</span><br></pre></td></tr></table></figure>
<p>Run the Flaskr app on this image, once the container is launched by the user.  </p>
<figure class="highlight bash"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"python"</span>, <span class="string">"flaskr.py"</span>, <span class="string">"--host"</span>, <span class="string">"0.0.0.0"</span>, <span class="string">"--port"</span>, <span class="string">"5000"</span>]</span><br></pre></td></tr></table></figure>
<p>The Dockerfile in full:</p>
<figure class="highlight bash"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM python:2.7</span><br><span class="line">ENV FLASKR_SETTINGS flaskr_settings</span><br><span class="line">ADD requirements.txt /tmp/requirements.txt</span><br><span class="line">RUN pip install -r /tmp/requirements.txt</span><br><span class="line">ADD . /flaskr-application</span><br><span class="line">WORKDIR /flaskr-application</span><br><span class="line">EXPOSE 5000</span><br><span class="line">CMD [<span class="string">"python"</span>, <span class="string">"flaskr.py"</span>, <span class="string">"--host"</span>, <span class="string">"0.0.0.0"</span>, <span class="string">"--port"</span>, <span class="string">"5000"</span>]</span><br></pre></td></tr></table></figure>
<p>Make sure your own file’s contents matches the above, and then save the changes. </p>
<hr>
<h1 id="4-–-Build-and-Run-the-Image"><a href="#4-–-Build-and-Run-the-Image" class="headerlink" title="4 – Build and Run the Image"></a>4 – Build and Run the Image</h1><p>Using Docker (which you should already <a href="http://www.tricksofthetrades.net/2015/12/23/installing-running-docker/">have installed</a>) we’re going to build the custom Flaskr image configured in the previous step. </p>
<p>When entering this next command be aware that ideally the parameters of <code>-t</code> need to be replaced with your own username and preferred image name. The details are used later on when registering the image externally. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --no-cache -t scarlz/flaskr-application .</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong> The <code>-t</code> option assigns a <em>tag</em> to the image used by Docker Hub or an image registry service. </p>
</blockquote>
<p>Give the build process a few minutes to download and carry out the necessary operations, noting its progress via the output. </p>
<p>If the Dockerfile was configured properly in the previous step you’ll get a final output similar to:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Successfully built c4e546ed282d</span><br></pre></td></tr></table></figure>
<p>Run the newly built Docker image in a daemonised container, mapping the internal container port <code>5000</code> to the host port <code>32775</code> so we can view the app locally. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name flaskr-container -p 32775:5000 <span class="_">-d</span> scarlz/flaskr-application</span><br></pre></td></tr></table></figure>
<p>Confirm the container has run and is running. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure>
<p>Running container details are returned:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">c3937994e66b        scarlz/flaskr-application   <span class="string">"python flaskr.py --h"</span>   3 seconds ago       Up 3 seconds        0.0.0.0:5000-&gt;32775/tcp   flaskr-container</span><br></pre></td></tr></table></figure>
<p>Preview the Flaskr app in your web browser by visiting:</p>
<p><code>http://0.0.0.0:32775</code></p>
<p><img src="http://i.imgur.com/sLe4eCC.png" alt="Flaskr Homepage Image"></p>
<p>Log in to the application with the authentication details from step 2 if you wish to test it out. </p>
<p><img src="http://i.imgur.com/wtTvZkZ.png" alt="Flaskr Internal Form Image"></p>
<hr>
<h2 id="5-–-Push-the-Image-to-Docker-Hub"><a href="#5-–-Push-the-Image-to-Docker-Hub" class="headerlink" title="5 – Push the Image to Docker Hub"></a>5 – Push the Image to Docker Hub</h2><p>Once images have been built and tested successfully you may want to make them accessible to others through a public or private Docker registry service. The official registry service open to all provided by Docker is known as <a href="https://hub.docker.com/" target="_blank" rel="external">“Docker Hub”</a>. </p>
<p>Create a free account by registering with the service at the previous link and then go back to the command line and login using:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure>
<p>Enter the authentication details you used to sign up to the service as prompted. </p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Username: </span><br><span class="line">Password: </span><br><span class="line">Email: </span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>
<p>Now once successfully authenticated push the image you created earlier to Docker Hub by providing the “tag” name assigned to it. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker push scarlz/flaskr-application:latest</span><br></pre></td></tr></table></figure>
<p>The <code>:latest</code> suffix ensures the most recently built version of the image is sent. </p>
<p>Successfully pushing the image will return an output akin to:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">77e39ee82117: Image successfully pushed</span><br></pre></td></tr></table></figure>
<p>You can see the example image I pushed to Docker Hub at: </p>
<p><a href="https://hub.docker.com/r/5car1z/flaskr-application" target="_blank" rel="external">https://hub.docker.com/r/5car1z/flaskr-application</a></p>
<p><img src="http://i.imgur.com/roVLQ0J.png" alt="Docker Hub - Flaskr"></p>
<hr>
<p>There are many more practices and nuances not covered here when it comes to building, tagging, and pushing to Docker registries. But hopefully this serves as a simple example of how the process can be carried out. Something to bear in mind perhaps is that Docker Hub has in the past been given bad press in terms of performance (most notably speed) although the service continues to improve as time goes on. it is also for these reasons or similar many use third party private registry platforms in its place e.g. <a href="">Portus</a></p>
<p>The next and final post in this series takes a glance briefly at some of the extra platforms/toolsets that form up more of the Docker eco-system.</p>
<p><a href="http://www.tricksofthetrades.net/trades/">Links to subsequent Docker posts can be found on the Trades page.</a></p>
<p><strong>More Information</strong></p>
<ul>
<li><a href="https://github.com/5car1z/docker-flaskr" target="_blank" rel="external">GitHub - Docker-Flaskr Repository</a> – Repository for this post cloned at the start.</li>
<li><a href="http://tiborsimko.org/docker-for-python-applications.html" target="_blank" rel="external">Tibor’s Musings - Using Docker for Developing Python Applications</a> – Basis of what goes on this blog post with adaption for Flaskr.</li>
<li><a href="">Official Docker Documentation - Build Your Own Images</a> – Probably best source for everything covered here. </li>
<li><a href="http://prakhar.me/docker-curriculum/" target="_blank" rel="external">Prakhar - Docker for Beginners</a> – Detailed guide on fundamentals of Docker, referred to partly for this post.</li>
<li><a href="https://community.nitrous.io/docs/creating-custom-docker-images" target="_blank" rel="external">Nitrous.io Documentation - Creating Custom Docker Images</a> – Specific to Nitrous development in parts but relevant overall. </li>
<li><a href="http://flask.readthedocs.io/en/latest/cli/#command-line-interface" target="_blank" rel="external">Flask Documentation - Command Line Interface</a> – Flask application CLI documentation page. </li>
</ul>
<blockquote>
<p>Easily deploy an SSD cloud server on <a href="https://www.digitalocean.com/?refcode=e91058dbfc7b" target="_blank" rel="external">Digital Ocean</a> in 55 seconds. Sign up using my link and receive $10.00 in free credit: <a href="https://www.digitalocean.com/?refcode=e91058dbfc7b" target="_blank" rel="external">https://www.digitalocean.com/?refcode=e91058dbfc7b</a></p>
</blockquote>
<p>– Scarlz: <a href="https://twitter.com/5car1z" target="_blank" rel="external">@5car1z</a></p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/Docker/" class="post__tag__link">Docker</a></li><li class="post__tag__item"><a href="/tags/Virtualisation/" class="post__tag__link">Virtualisation</a></li><li class="post__tag__item"><a href="/tags/Containers/" class="post__tag__link">Containers</a></li></ul><a href="/2016/05/18/docker-images-hub/#disqus_thread" class="post__foot-link u-fr">COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2016-03-14T00:00:00.000Z" class="post__time">March 14, 2016</time><h1 class="post__title"><a href="/2016/03/14/docker-data-volumes/">Docker - Data Volumes and Data Containers (4)</a></h1></header><div class="post__main echo"><p><img src="http://i.imgur.com/poo8Rai.png" alt="Docker Logo"></p>
<h1 id="Preamble"><a href="#Preamble" class="headerlink" title="Preamble"></a>Preamble</h1><blockquote>
<p><strong><a href="https://docs.docker.com/engine/admin/volumes/volumes/" target="_blank" rel="external">This blog post is becoming more and more outdated as time goes on, it would be better to consult the official Docker documentation for this kind of thing!</a></strong></p>
</blockquote>
<p>Docker containers are a lot more scalable and modular once they have the links in place that allow them to share data. How these links are created and arranged depends upon the arranger, who will choose either to create a file-system data volume or a dedicated data volume container. </p>
<p>This post works through these two common choices; data volumes and data volume containers. With consideration of the commands involved in backing up, restoring, and migrating said data volumes.</p>
<p>This is post four on Docker following on from <a href="http://www.tricksofthetrades.net/2016/01/27/docker-further-administration-networking/">Docker - Daemon Administration and Networking (3)</a>. Go back and read the latter half of that post to see how to network containers together so they can properly communicate back and forth - if you need to. </p>
<a id="more"></a>
<hr>
<h1 id="1-–-Creating-Data-Volumes"><a href="#1-–-Creating-Data-Volumes" class="headerlink" title="1 – Creating Data Volumes"></a>1 – Creating Data Volumes</h1><p>A “data volume” is a marked directory inside of a container that exists to hold persistent or commonly shared data. Assigning these volumes is done when creating a new container. </p>
<p>Any data already present as part of the Docker image in a targeted volume directory is carried forward into the new container and not lost. This however is not true when mounting a local host directory (covered later) as the data is temporarily covered by the new volume. </p>
<iframe width="1080" height="500" src="https://www.youtube.com/embed/e1yXmc7-mU4" frameborder="1" allowfullscreen><br></iframe> 

<p>You can add a data volume to a container using the <code>-v</code> flag in conjunction with the <code>create</code> or <code>run</code> command. You can use the -<code>v</code> multiple times to mount multiple data volumes.</p>
<p>This next command will create a data volume inside a new container in the <code>/webapp</code> directory. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run <span class="_">-d</span> -P --name <span class="built_in">test</span>-container -v /webapp training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>Data volumes are very useful as once designated and created they can be shared and included as part of other containers. It’s also important to note that any changes to data volumes are not included when you update an image, but conversely data volumes will persist even if the container itself is deleted.</p>
<blockquote>
<p><strong>Note:</strong> The <code>VOLUME</code> instruction in a <code>Dockerfile</code> will add one or more new volumes to any containers created from the image.</p>
</blockquote>
<p>This preservation is due to the fact that data volumes are meant to persist independent of a container’s life cycle. In turn this also means Docker never <em>garbage collects</em> volumes that are no longer in use by a container. </p>
<hr>
<h1 id="2-–-Creating-Host-Data-Volumes"><a href="#2-–-Creating-Host-Data-Volumes" class="headerlink" title="2 – Creating Host Data Volumes"></a>2 – Creating Host Data Volumes</h1><p>You can instead mount a directory from your Docker daemon’s <strong>host</strong> into a container; you may have seen this used once or twice in the previous posts. </p>
<p>Mounting a host directory can be useful for testing. For example, you can mount source code inside a container. Then, change the source code and see its effect on the application in real time. The directory on the host must be specified as an absolute path and if the directory doesn’t exist Docker will automatically create it for you. </p>
<p>The next example command mounts the host directory <code>/src/webapp</code> into the container at the <code>/opt/webapp</code> directory. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run <span class="_">-d</span> -P --name <span class="built_in">test</span>-container -v /src/webapp:/opt/webapp training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>Some internal rules and behaviours for this process are:</p>
<ul>
<li><p>The targeted container directory must always take an absolute full file-system path.</p>
</li>
<li><p>The host source directory can be either an absolute path or a name value. </p>
</li>
<li><p>If the targeted container path already exists inside the container’s image, the host directory mount overlays but does not remove the destination content. Once the mount is removed, the destination content is accessible again. </p>
</li>
</ul>
<p>Docker volumes default to mounting as both a dual read-write mode, but you can set them to mount as read-only if you like.</p>
<p>Here the same <code>/src/webapp</code> directory is linked again but the extra <code>:ro</code> option makes the mount read-only.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run <span class="_">-d</span> -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong> It’s not possible to mount a host directory using a <code>Dockerfile</code> because by convention images should be portable and flexible, and a specific host directory might not be available on all potential hosts.</p>
</blockquote>
<hr>
<h1 id="3-–-Mounting-Individual-Host-Files"><a href="#3-–-Mounting-Individual-Host-Files" class="headerlink" title="3 – Mounting Individual Host Files"></a>3 – Mounting Individual Host Files</h1><p>The <code>-v</code> flag used so far can target a single file instead of entire directories from the host machine. This is done by mapping the specific file on each side of the container. </p>
<p>A great interactive example of this that creates a new container and drops you into a bash shell with your bash history from the host, is as follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it -v ~/.bash_history:/root/.bash_history ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>Furthermore when you exit the container, the host version of the file will have the the commands typed from the inside of the container - written to the the <code>.bash_history</code> file. </p>
<hr>
<h1 id="4-–-Creating-Dedicated-Data-Volume-Containers"><a href="#4-–-Creating-Dedicated-Data-Volume-Containers" class="headerlink" title="4 – Creating Dedicated Data Volume Containers"></a>4 – Creating Dedicated Data Volume Containers</h1><p>A popular practice with Docker data sharing is to create a dedicated container that holds all of your persistent shareable data resources, mounting the data inside of it into other containers once created and setup. </p>
<p>This example taken from the Docker documentation uses the <code>postgres</code> SQL training image as a base for the data volume container. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker create -v /data-store --name data-store training/postgres /bin/<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong> <code>/bin/true</code> - returns a <code>0</code> and does nothing if the command was successful. </p>
</blockquote>
<p>The <code>--volumes-from</code> flag is then used to mount the <code>/data-store</code> volume inside of other containers:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run <span class="_">-d</span> --volumes-from data-store --name database-container-1 training/postgres</span><br></pre></td></tr></table></figure>
<p>This process is repeated for additional new containers:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run <span class="_">-d</span> --volumes-from data-store --name database-container-2  training/postgres</span><br></pre></td></tr></table></figure>
<p>Be aware that you can use multiple <code>--volumes-from</code> flags in one command to combine data volumes from multiple other dedicated data containers. </p>
<p>An alternative idea is to mount the volumes from each subsequent container to the next, instead of the original dedicated container linking to new ones. </p>
<p>This forms a chain that would begin by using: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run <span class="_">-d</span> --name database-container-3 --volumes-from database-container-2  training/postgres</span><br></pre></td></tr></table></figure>
<p>Remember that If you remove containers that mount volumes, the volume store and its data will not be deleted. Docker preserves it. </p>
<p>To fully delete a volume from the file-system you must run:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm -v &lt;container name&gt;</span><br></pre></td></tr></table></figure>
<p>Where <code>&lt;container name&gt;</code> is “the last container with a reference to the volume.”</p>
<blockquote>
<p><strong>Note:</strong> There is no cautionary Docker warning provided when removing a container without  the <code>-v</code> option.  So if a container has volumes mounted the <code>-v</code> must be passed to fully remov them. </p>
</blockquote>
<h2 id="Dangling-Volumes"><a href="#Dangling-Volumes" class="headerlink" title="Dangling Volumes"></a>Dangling Volumes</h2><p>“Dangling volumes” refers to container volumes that are no longer referenced by a container.</p>
<p>Fortunately there is a command to list out all the stray volumes on a system.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls <span class="_">-f</span> dangling=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>To remove a volume that’s no longer needed use:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm &lt;volume name&gt;</span><br></pre></td></tr></table></figure>
<p>Where <code>&lt;volume name&gt;</code> is substituted for the dangling volume name shown in the previous <code>ls</code> output. </p>
<hr>
<h1 id="5-–-Backing-Up-and-Restoring-Data-Volumes"><a href="#5-–-Backing-Up-and-Restoring-Data-Volumes" class="headerlink" title="5 – Backing Up and Restoring Data Volumes"></a>5 – Backing Up and Restoring Data Volumes</h1><p>How are data volumes maintained when it comes to things like backups, restoration, and migration? Well here is one solution that takes care of these necessities by showing how you can achieve this with a dedicated data container. </p>
<p>To backup a volume:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --volumes-from data-container -v $(<span class="built_in">pwd</span>):/backup ubuntu tar cvf /backup/backup.tar /data-store</span><br></pre></td></tr></table></figure>
<p>Here’s how the previous command works:</p>
<ol>
<li>The <code>--volumes-from</code> flag creates a new nameless container that mounts the data volume inside <code>data-container</code> you wish to backup. </li>
<li>A localhost directory is mounted as <code>/backup</code> . Then <code>tar</code> archives the contents of the <code>/data-store</code> volume to a <code>backup.tar</code> file inside the local <code>/backup</code> directory. </li>
<li>The container will be <code>--rm</code> removed once it eventually ends and exits. </li>
</ol>
<p>We are left with a backup of the <code>/data-store</code> volume on the localhost. </p>
<p>From here you could restore the volume in whatever way you wish.</p>
<p>To restore into a new container run: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -v /data-store --name data-container-2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>Then extract the backup file contents into the the new container’s data volume:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --volumes-from data-container-2 -v $(<span class="built_in">pwd</span>):/backup ubuntu bash -c <span class="string">"cd /data-store &amp;&amp; tar -xvf /backup/backup.tar"</span></span><br></pre></td></tr></table></figure>
<p>Now the new container is up and running with the files from the original <code>/data-store</code> volume. </p>
<hr>
<h1 id="6-–-Volume-and-Data-Container-Issues"><a href="#6-–-Volume-and-Data-Container-Issues" class="headerlink" title="6 – Volume and Data Container Issues"></a>6 – Volume and Data Container Issues</h1><ul>
<li><p><strong>Orphan Volumes</strong> – Referred to as dangling volumes earlier on. These are the leftover untracked volumes that aren’t removed from the system once a container is removed/deleted. </p>
</li>
<li><p><strong>Security</strong> – Other than the usual Unix file permissions and the ability to set read-only or read-write privileges. Docker volumes or data containers have no additional security placed on them. </p>
</li>
<li><p><strong>Data Integrity</strong> – Sharing data using volumes and data containers provides no level of data integrity protection. Data protection features are not yet built into Docker i.e. data snapshot, automatic data replication, automatic backups, etc. So data management has to be handled by the administrator or the container itself. </p>
</li>
<li><p><strong>External Storage</strong> –  The current design does not take into account the ability to use a Docker volume spanning from one host to another. They must be on the same host. </p>
</li>
</ul>
<hr>
<p>It seems like a large amount of information has been covered here but really only two ideas have been explored. That of singular data volumes and that of the preferred independent data container. There are also new updates to Docker on the horizon as always so some of the issues raised here are hopefully soon to be resolved. The next post on Docker covers building images using Dockerfiles, and likewise with Docker Compose. </p>
<p><a href="http://www.tricksofthetrades.net/trades/">Links to subsequent Docker posts can be found on the Trades page.</a></p>
<p><strong>More Information</strong></p>
<ul>
<li><a href="https://docs.docker.com/engine/userguide/dockervolumes/" target="_blank" rel="external">Official Docker Documentation – Manage Data in Containers</a> – Main source material used for this post. </li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-work-with-docker-data-volumes-on-ubuntu-14-04" target="_blank" rel="external">Digital Ocean - How To Work with Docker Data Volumes on Ubuntu 14.04</a> – Breaks down the topic further and has some Nginx logging volume mount examples. </li>
<li><a href="http://www.computerweekly.com/feature/Docker-storage-101-How-storage-works-in-Docker" target="_blank" rel="external">Docker storage 101: How storage works in Docker</a> – Article from April 2015 that goes over the general ideas and practices discussed here. </li>
</ul>
<blockquote>
<p>Easily deploy an SSD cloud server on <a href="https://www.digitalocean.com/?refcode=e91058dbfc7b" target="_blank" rel="external">Digital Ocean</a> in 55 seconds. Sign up using my link and receive $10.00 in free credit: <a href="https://www.digitalocean.com/?refcode=e91058dbfc7b" target="_blank" rel="external">https://www.digitalocean.com/?refcode=e91058dbfc7b</a></p>
</blockquote>
<p>– Scarlz: <a href="https://twitter.com/5car1z" target="_blank" rel="external">@5car1z</a></p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/Docker/" class="post__tag__link">Docker</a></li><li class="post__tag__item"><a href="/tags/Virtualisation/" class="post__tag__link">Virtualisation</a></li><li class="post__tag__item"><a href="/tags/Containers/" class="post__tag__link">Containers</a></li></ul><a href="/2016/03/14/docker-data-volumes/#disqus_thread" class="post__foot-link u-fr">COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2016-01-27T00:00:00.000Z" class="post__time">January 27, 2016</time><h1 class="post__title"><a href="/2016/01/27/docker-further-administration-networking/">Docker - Daemon Administration and Networking (3)</a></h1></header><div class="post__main echo"><p><img src="http://i.imgur.com/poo8Rai.png" alt="Docker Logo Image"></p>
<h1 id="Preamble"><a href="#Preamble" class="headerlink" title="Preamble"></a>Preamble</h1><p>This time we are beginning by centering around the Docker daemon and how it interacts with various process mangers from different platforms. Followed up by an introduction to networking in Docker that uses more of the Docker training images to link together and create a basic network of containers. Specifically a PostgreSQL database container and a Python webapp container.  </p>
<p>This is post three on Docker following on from <a href="http://www.tricksofthetrades.net/2016/01/07/docker-administration-applications/">Docker - Administration and Container Applications (2)</a>. If you’re looking for more generalised administration and basic example uses of the Docker Engine CLI then you may want to read that post instead. </p>
<a id="more"></a>
<hr>
<h1 id="1-–-Docker-Daemon-Administration"><a href="#1-–-Docker-Daemon-Administration" class="headerlink" title="1 – Docker Daemon Administration"></a>1 – Docker Daemon Administration</h1><p>The Docker daemon is the background service that handles running containers and all their states. </p>
<p>The starting and stopping of the Docker daemon is often configured through a process manager like systemd or Upstart. In a production environment this is very useful as you have a lot of customisable control over the behaviour of the daemon. </p>
<p>It can be run directly from the command line though instead of this:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker daemon</span><br></pre></td></tr></table></figure>
<p>It listens on the Unix socket - <code>unix:///var/run/docker.sock</code> when active and running. </p>
<p>If you’re running the docker daemon directly like this you can append configuration options to the command.</p>
<p>An example of running the docker <a href="https://docs.docker.com/engine/reference/commandline/daemon/" target="_blank" rel="external">daemon</a> with configuration options is as follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker daemon -D --tls=<span class="literal">true</span> --tlscert=/var/docker/server.pem --tlskey=/var/docker/serverkey.pem -H tcp://192.168.59.3:2376</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-D</code> <code>--debug=false</code>    – Enable or disable debug mode. </li>
<li><code>--tls=false</code> – Enable or disable TLS. </li>
<li><code>--tlscert=</code> – certificate location. </li>
<li><code>tlskey=</code> – key location. </li>
<li><code>-H</code> <code>--host=[]</code> – Daemon socket(s) to connect to.</li>
</ul>
<p>More options are on offer for the Docker daemon at the link before the last code block. </p>
<h2 id="Upstart"><a href="#Upstart" class="headerlink" title="Upstart"></a>Upstart</h2><p>The default Docker daemon Upstart job is found in <code>/etc/init/docker.conf</code> .</p>
<p>To check the status of the daemon:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo status docker</span><br></pre></td></tr></table></figure>
<p>To start the Docker daemon:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo start docker</span><br></pre></td></tr></table></figure>
<p>Stop the Docker daemon:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo stop docker</span><br></pre></td></tr></table></figure>
<p>Or restart the daemon:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo restart docker</span><br></pre></td></tr></table></figure>
<p>Logs for Upstart jobs are found in <code>/var/log/upstart</code> and are compressed when the daemon is not running. So run the daemon/container to read the active log file - <code>docker.log</code> via:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tail -fn 15 /var/<span class="built_in">log</span>/upstart/docker.log</span><br></pre></td></tr></table></figure>
<h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p>Default unit files are stored in the subdirectories of <code>/usr/lib/systemd</code> and <code>/lib/systemd/system</code> . Custom user created unit files are kept in <code>/etc/systemd/system</code> .</p>
<p>To check the status of the daemon:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status docker</span><br></pre></td></tr></table></figure>
<p>To start the Docker daemon:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>Stop the Docker daemon:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br></pre></td></tr></table></figure>
<p>Or restart the daemon:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>To ensure the Docker daemon starts at boot:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br></pre></td></tr></table></figure>
<p>Logs for Docker are viewed in systemd with:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl -u docker</span><br></pre></td></tr></table></figure>
<p>A more in-depth look at systemd and Docker is kept here in the Docker docs:</p>
<blockquote>
<p><a href="https://docs.docker.com/engine/articles/systemd/" target="_blank" rel="external">Docker Documentation - systemd</a></p>
</blockquote>
<hr>
<h1 id="2-–-Process-Manager-Container-Automation"><a href="#2-–-Process-Manager-Container-Automation" class="headerlink" title="2 – Process Manager Container Automation"></a>2 – Process Manager Container Automation</h1><p><em>Restart policies</em> are an in-built Docker mechanism for restarting containers automatically when they exit. These must be set manually with the flag - <code>--restart=&quot;yes&quot;</code> and are also triggered when the Docker daemon starts up (like after a system reboot). Restart policies start linked containers in the correct order too. </p>
<p>If you have non-Docker processes that depend on Docker containers you can use a process manager like upstart, systemd or supervisor instead of these restart policies to replace this functionality. </p>
<p>This is what we will cover in this step.</p>
<blockquote>
<p><strong>Note:</strong> Be aware that process mangers will conflict with Docker restart policies if they are both in action So don’t run restart policies if you are using a process manager.</p>
</blockquote>
<p>For these examples assume that the container’s for each have already been created and are running Ghost with the name <code>--name=ghost-container</code> . </p>
<h2 id="Upstart-1"><a href="#Upstart-1" class="headerlink" title="Upstart"></a>Upstart</h2><figure class="highlight bash"><figcaption><span>/etc/init/ghost.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">description <span class="string">"Ghost Blogging Container"</span></span><br><span class="line">author <span class="string">"Scarlz"</span></span><br><span class="line">start on filesystem and started docker</span><br><span class="line">stop on runlevel [!2345]</span><br><span class="line">respawn</span><br><span class="line">script</span><br><span class="line">  /usr/bin/docker start <span class="_">-a</span> ghost-container</span><br><span class="line">end script</span><br></pre></td></tr></table></figure>
<p>Docker automatically attaches the process manager to the running container, or starts it if needed with this setup.</p>
<p>All signals from Docker are also forwarded so that the process manager can detect when a container stops, to correctly restart it.</p>
<p>If you need to pass options to the containers (such as <code>--env</code>) then you’ll need to use <code>docker run</code> rather than <code>docker start</code> in the job configuration.</p>
<p>For Example: </p>
<figure class="highlight bash"><figcaption><span>/etc/init/ghost.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">script</span><br><span class="line">  /usr/bin/docker run --env foo=bar --name ghost-container ghost</span><br><span class="line">end script</span><br></pre></td></tr></table></figure>
<p>This differs as it creates a new container using the <code>ghost</code> image every time the service is started and takes into account the extra options. </p>
<h2 id="systemd-1"><a href="#systemd-1" class="headerlink" title="systemd"></a>systemd</h2><figure class="highlight bash"><figcaption><span>/etc/systemd/system/ghost</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Ghost Blogging Container</span><br><span class="line">Requires=docker.service</span><br><span class="line">After=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Restart=always</span><br><span class="line">ExecStart=/usr/bin/docker start <span class="_">-a</span> ghost-container</span><br><span class="line">ExecStop=/usr/bin/docker stop -t 2 ghost-container</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=local.target</span><br></pre></td></tr></table></figure>
<p>Docker automatically attaches the process manager to the running container, or starts it if needed with this setup. </p>
<p>All signals from Docker are also forwarded so that the process manager can detect when a container stops, to correctly restart it.</p>
<p>If you need to pass options to the containers (such as <code>--env</code>), then you’ll need to use <code>docker run</code> rather than <code>docker start</code> in the job configuration.</p>
<p>For Example: </p>
<figure class="highlight bash"><figcaption><span>/etc/systemd/system/ghost</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/docker run --env foo=bar --name ghost-container ghost</span><br><span class="line">ExecStop=/usr/bin/docker stop -t 2 ghost-container ; /usr/bin/docker rm <span class="_">-f</span> ghost-container</span><br></pre></td></tr></table></figure>
<p>This differs as it creates a new container with the extra options every time the service is started, which stops and removes itself when the Docker service ends. </p>
<hr>
<h1 id="3-–-Docker-Networks"><a href="#3-–-Docker-Networks" class="headerlink" title="3 – Docker Networks"></a>3 – Docker Networks</h1><p>Network drivers allow containers to be linked together and networked. Docker comes with two default network drivers as part of the normal installation:</p>
<ul>
<li>The bridge driver.  </li>
<li>The overlay driver. </li>
</ul>
<p>These two drivers are replaceable with other third party drivers that perform more optimally in different situations. But for low end basic Docker use these given defaults are fine. </p>
<p>Docker also automatically includes three default networks with the base install:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br></pre></td></tr></table></figure>
<p>Listing them as:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER</span><br><span class="line">2d41f8bbf514        host                host                </span><br><span class="line">f9ee6308ecdd        bridge              bridge              </span><br><span class="line">49dab653f349        none                null</span><br></pre></td></tr></table></figure>
<p>The network named <code>bridge</code> is classed as a special network. Docker launches any and all containers in this network (unless told otherwise). </p>
<p>So if you currently you have containers running these will have been placed into the <code>bridge</code> network group. </p>
<p>Networks can be <a href="https://docs.docker.com/engine/reference/commandline/network_inspect/" target="_blank" rel="external">inspected</a> using the next command, where <code>bridge</code> is the network name to be inspected:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect bridge</span><br></pre></td></tr></table></figure>
<p>The output shows any and all configured directives for the network:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"f9ee6308ecdd5dc5a588428469de1b7c475fdafdab49cfc33c1c3ac0bf0559ab"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"172.17.0.0/16"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"ff98b5ed01dd4323f0ce38af9b8cea2d49d0b1e194cf147a3a8f632278a11451"</span>: &#123;</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"b7c9fabcda00ccebd6523f76477b51eba00dd5d3f26940355139fff62d5576bb"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"172.17.0.2/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;</span><br><span class="line">            <span class="string">"com.docker.network.bridge.default_bridge"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.enable_icc"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.host_binding_ipv4"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.name"</span>: <span class="string">"docker0"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.driver.mtu"</span>: <span class="string">"1500"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>This <code>inspect</code> output changes as a network is altered and configured, how to do this is covered in later steps. </p>
<hr>
<h1 id="4-–-Creating-Docker-Networks"><a href="#4-–-Creating-Docker-Networks" class="headerlink" title="4 – Creating Docker Networks"></a>4 – Creating Docker Networks</h1><p>Networks are natural ways to isolate containers from other containers or other networks. The original default networks are not to be solely relied upon however. It’s better to create your own network groups.</p>
<p>Remember there are two default drivers and therefore two native network types; <code>bridge</code> and <code>overlay</code> . Bridge networks can only make use of one singular host to run the Docker Engine software. An overlay network differs in that it can incorporate multiple hosts into running the Docker software. </p>
<p>To make the simpler “bridge” type network we use the <code>create</code> option:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create <span class="_">-d</span> bridge &lt;new-network-name&gt;</span><br></pre></td></tr></table></figure>
<p>With this last command the <code>-d</code> (driver) and <code>bridge</code> option specifies the network type we want to create. With a new name for the network at the end of the command. </p>
<p>To see the new network after creation:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br></pre></td></tr></table></figure>
<p>Shown on the last line:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                  DRIVER</span><br><span class="line">f9ee6308ecdd        bridge                bridge              </span><br><span class="line">49dab653f349        none                  null                </span><br><span class="line">2d41f8bbf514        host                  host                </span><br><span class="line">08f44ef7de28        <span class="built_in">test</span>-bridge-network   bridge</span><br></pre></td></tr></table></figure>
<p>Overlay networks are a much wider topic due to their inclusion of multiple hosts so aren’t covered in this post but the basic principles and where to start is mentioned in the link below:    </p>
<blockquote>
<p><a href="https://docs.docker.com/engine/userguide/networking/work-with-networks/" target="_blank" rel="external">Docker Documentation - Working with Network Commands</a></p>
</blockquote>
<hr>
<h1 id="5-–-Connecting-Containers-to-Networks"><a href="#5-–-Connecting-Containers-to-Networks" class="headerlink" title="5 – Connecting Containers to Networks"></a>5 – Connecting Containers to Networks</h1><p>Creating and using these networks allows container applications to to operate in unison and as securely as possible. Containers inside of networks can only interact with their counterparts and are isolated from the outsides of the network. Similar to VLAN segregation inside of a IP based network.    </p>
<p>Usually containers are added to a network when you first launch and run the container. We’ll follow the example from the Docker Documentation that uses a PostgreSQL database container and the Python webapp to demonstrate a simple network configuration. </p>
<p>First launch a container running the PostgreSQL database training image, and in the process add it to your custom made bridge network from the previous step. </p>
<p>To do this we must pass the <code>--net=</code> flag to the new container, and provide it with the name of our custom bridge network. Which in my example earlier was <code>test-bridge-network</code> :  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run <span class="_">-d</span> --net=<span class="built_in">test</span>-bridge-network --name db training/postgres</span><br></pre></td></tr></table></figure>
<p>You can inspect this aptly named <code>db</code> container to see where exactly it is connected:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format=<span class="string">'&#123;&#123;json .NetworkSettings.Networks&#125;&#125;'</span> db</span><br></pre></td></tr></table></figure>
<p>This shows us the network details for the database container’s <code>test-bridge-network</code> connection:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"test-bridge-network"</span>:&#123;<span class="string">"EndpointID"</span>:<span class="string">"0008c8566542ef24e5e57d5911c8e33a79f0fcb91b1bbdd60d5cdec3217fb517"</span>,<span class="string">"Gateway"</span>:<span class="string">"172.18.0.1"</span>,<span class="string">"IPAddress"</span>:<span class="string">"172.18.0.2"</span>,<span class="string">"IPPrefixLen"</span>:16,<span class="string">"IPv6Gateway"</span>:<span class="string">""</span>,<span class="string">"GlobalIPv6Address"</span>:<span class="string">""</span>,<span class="string">"GlobalIPv6PrefixLen"</span>:0,<span class="string">"MacAddress"</span>:<span class="string">"02:42:ac:12:00:02"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Next run the Python training web application in daemonised mode with out any extra options:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run <span class="_">-d</span> --name python-webapp training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>Inspect the <code>python-webapp</code> container’s network connection in the same way as before: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format=<span class="string">'&#123;&#123;json .NetworkSettings.Networks&#125;&#125;'</span> python-webapp</span><br></pre></td></tr></table></figure>
<p>As expected this new container is running under the <strong>default</strong> bridge network, shown in the output of the last command:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"bridge"</span>:&#123;<span class="string">"EndpointID"</span>:<span class="string">"e5c7f1c8d097fdafc35b89d7bce576fe01a22709424643505d79abe394a59767"</span>,<span class="string">"Gateway"</span>:<span class="string">"172.17.0.1"</span>,<span class="string">"IPAddress"</span>:<span class="string">"172.17.0.2"</span>,<span class="string">"IPPrefixLen"</span>:16,<span class="string">"IPv6Gateway"</span>:<span class="string">""</span>,<span class="string">"GlobalIPv6Address"</span>:<span class="string">""</span>,<span class="string">"GlobalIPv6PrefixLen"</span>:0,<span class="string">"MacAddress"</span>:<span class="string">"02:42:ac:11:00:02"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Docker lets us connect a container to as many networks as we like. More importantly for us we can also connect an already running container to a network. </p>
<p>Attach the running <code>python-webapp</code> container to the “test-bridge-network” like we need:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network connect test-bridge-network python-webapp</span><br></pre></td></tr></table></figure>
<p>To test the container connections to our custom network we can ping from one to the other.</p>
<p>Get the IP address of the <code>db</code> container:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format=<span class="string">'&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;'</span> db</span><br></pre></td></tr></table></figure>
<p>In my case this was:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.18.0.2</span><br></pre></td></tr></table></figure>
<p>Now we have the IP address open an interactive shell into the <code>python-webapp</code> container:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it python-webapp bash</span><br></pre></td></tr></table></figure>
<p>Attempt to ping the <code>db</code> container with the IP address from before, substituting <code>172.18.0.2</code>  for your address equivalent:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 10 172.18.0.2</span><br></pre></td></tr></table></figure>
<p>As long as you successfully connected both containers earlier on, the ping command will be successful:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="built_in">fc</span>0f73c129c0:/opt/webapp<span class="comment"># ping -c 10 db</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from db (172.18.0.2): icmp_seq=1 ttl=64 time=0.216 ms</span><br><span class="line">64 bytes from db (172.18.0.2): icmp_seq=2 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from db (172.18.0.2): icmp_seq=3 ttl=64 time=0.053 ms</span><br><span class="line">64 bytes from db (172.18.0.2): icmp_seq=4 ttl=64 time=0.063 ms</span><br><span class="line">64 bytes from db (172.18.0.2): icmp_seq=5 ttl=64 time=0.065 ms</span><br><span class="line">64 bytes from db (172.18.0.2): icmp_seq=6 ttl=64 time=0.063 ms</span><br><span class="line">64 bytes from db (172.18.0.2): icmp_seq=7 ttl=64 time=0.062 ms</span><br><span class="line">64 bytes from db (172.18.0.2): icmp_seq=8 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from db (172.18.0.2): icmp_seq=9 ttl=64 time=0.061 ms</span><br><span class="line">64 bytes from db (172.18.0.2): icmp_seq=10 ttl=64 time=0.063 ms</span><br><span class="line"></span><br><span class="line">--- db ping statistics ---</span><br><span class="line">10 packets transmitted, 10 received, 0% packet loss, time 8997ms</span><br><span class="line">rtt min/avg/max/mdev = 0.053/0.076/0.216/0.047 ms</span><br></pre></td></tr></table></figure>
<p>Conveniently container names work in the place of an IP address too in this scenario:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 10 db</span><br></pre></td></tr></table></figure>
<p>Press <code>CTRL</code> + <code>D</code> to exit the container prompt, or type in <code>exit</code> instead. </p>
<p>And with that we have two containers on the same user created network able to communicate with each other, and able to share data. Which is what we would be aiming for in the case of the PostgreSQL database and Python webapp.  </p>
<p>There’s more ways of sharing data between containers once they are connected through a network, but these are covered in the next post of the series. </p>
<hr>
<h1 id="6-–-Miscellaneous-Networking-Commands"><a href="#6-–-Miscellaneous-Networking-Commands" class="headerlink" title="6 – Miscellaneous Networking Commands"></a>6 – Miscellaneous Networking Commands</h1><p>Here are a few complimentary commands in relation to what has already been covered in this post.</p>
<p>At some point you are likely to need to remove a container from its network. This is done by using the <code>disconnect</code> command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network disconnect <span class="built_in">test</span>-bridge-network &lt;container-name&gt;</span><br></pre></td></tr></table></figure>
<p>Here <code>test-bridge-network</code> is the name of the network, followed by which container you want to remove from it. </p>
<p>When all the containers in a network are stopped or disconnected, you can remove networks themselves completely with:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network rm <span class="built_in">test</span>-bridge-network</span><br></pre></td></tr></table></figure>
<p>Meaning the <code>test-bridge-network</code> is now deleted and absent from the list of existing networks:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                  DRIVER             </span><br><span class="line">2e38b3a44489        bridge                bridge              </span><br><span class="line">79d9d21edbec        none                  null                </span><br><span class="line">61371e641e1b        host                  host</span><br></pre></td></tr></table></figure>
<p>The output here is garnered from the <code>docker network ls</code> command. </p>
<hr>
<p>Networking in Docker begins here with these examples but goes a lot further than what we’ve covered. Data volumes, data containers, and mounting host volumes are described in the next post on Docker when it’s released. </p>
<p><a href="http://www.tricksofthetrades.net/trades/">Links to subsequent Docker posts can be found on the Trades page.</a></p>
<p><strong>More Information</strong></p>
<ul>
<li><a href="https://docs.docker.com/engine/articles/configuring/" target="_blank" rel="external">Docker Docs - Configuring and Running Docker on Various Distributions</a> – Covers the daemon setup and is the main source for the first few steps of this post.  </li>
<li><a href="https://docs.docker.com/engine/articles/host_integration/" target="_blank" rel="external">Docker Docs -Automatically Start Containers</a> – Is mostly step 2 and has the bases for the process manger uptime script examples. </li>
<li><a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="external">Docker Docs - Networking Containers</a> – Anything and everything networking wise in this post comes from this. </li>
</ul>
<blockquote>
<p>Easily deploy an SSD cloud server on <a href="https://www.digitalocean.com/?refcode=e91058dbfc7b" target="_blank" rel="external">Digital Ocean</a> in 55 seconds. Sign up using my link and receive $10.00 in free credit: <a href="https://www.digitalocean.com/?refcode=e91058dbfc7b" target="_blank" rel="external">https://www.digitalocean.com/?refcode=e91058dbfc7b</a></p>
</blockquote>
<p>– Scarlz: <a href="https://twitter.com/5car1z" target="_blank" rel="external">@5car1z</a></p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/Docker/" class="post__tag__link">Docker</a></li><li class="post__tag__item"><a href="/tags/Virtualisation/" class="post__tag__link">Virtualisation</a></li><li class="post__tag__item"><a href="/tags/Containers/" class="post__tag__link">Containers</a></li></ul><a href="/2016/01/27/docker-further-administration-networking/#disqus_thread" class="post__foot-link u-fr">COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2016-01-07T00:00:00.000Z" class="post__time">January 7, 2016</time><h1 class="post__title"><a href="/2016/01/07/docker-administration-applications/">Docker - Administration and Container Applications (2)</a></h1></header><div class="post__main echo"><p><img src="http://i.imgur.com/poo8Rai.png" alt="Docker Logo Image"></p>
<h1 id="Preamble"><a href="#Preamble" class="headerlink" title="Preamble"></a>Preamble</h1><p>In this post we run a python program in a Docker container sourced from the user guide. Look at the various commands that come into play when administering containers, and then briefly setup some real world applications with Docker. </p>
<p>This will be the second post on Docker following on from <a href="http://www.tricksofthetrades.net/2015/12/23/installing-running-docker/">Docker - Installing and Running (1)</a>. If you’re brand new to Docker then the first post linked helps to introduce some of its concepts and theory to better understand the utilities it can provide. </p>
<a id="more"></a>
<hr>
<h1 id="1-–-Example-Container-Application"><a href="#1-–-Example-Container-Application" class="headerlink" title="1 – Example Container Application"></a>1 – Example Container Application</h1><p>Pull this training image from the Docker user guide:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run <span class="_">-d</span> -P training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>The <code>-d</code> option tells Docker to daemonise and run the container in the background. <code>-P</code> maps any required network ports inside the container to your host, and the Python application inside is also executed at the end. </p>
<p>Run the Docker process command to see running container details:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure>
<p>The “webapp” image container shows network ports that have been mapped as part of the image configuration:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">b8a16d8e94cc        training/webapp     <span class="string">"python app.py"</span>     2 minutes ago      Up 2 minutes       0.0.0.0:32768-&gt;5000/tcp   nostalgic_knuth</span><br></pre></td></tr></table></figure>
<p>In my example here port <code>5000</code> (the default Python Flask port) inside the container has been exposed on the host ephemeral TCP port <code>32768</code> . <em>Ephemeral</em> port ranges are temporary short lived port numbers which typically range anywhere from 32768 to 61000. These are dynamically used and are never set in stone. </p>
<p>The Docker image decides all this for us, but as an aside it’s also possible to manually sets the ports to use by a container. </p>
<p>This command assigns port <code>80</code> on the local host to port <code>5000</code> inside the container:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run <span class="_">-d</span> -p 80:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>It’s important never to map ports in a 1:1 fashion i.e. <code>5000-&gt;5000/tcp</code> as if we needed multiple containers running the same image, the traffic will use the same host port (<code>5000</code>) and only be accessible one instance at a time. </p>
<p>If you like you can check the original Python docker container’s port is working by accessing:</p>
<p><a href="http://localhost:32768" target="_blank" rel="external">http://localhost:32768</a> or <a href="http://your.hosts.ip.address:32768" target="_blank" rel="external">http://your.hosts.ip.address:32768</a> in a browser.</p>
<p>Where the port number <code>32768</code> is set to your own example container’s ephemeral port. </p>
<p>Another way to see this example containers image’s port configuration is:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker port &lt;container-name&gt;</span><br></pre></td></tr></table></figure>
<p>Showing:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32768-&gt;5000/tcp</span><br></pre></td></tr></table></figure>
<p>To see the front facing host machine’s mapped ports individually add the number of the internal port to the end of the command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker port &lt;container-name&gt; 5000</span><br></pre></td></tr></table></figure>
<p>Which shows:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0:32768</span><br></pre></td></tr></table></figure>
<p>Now we have this example container up and running we’ll go through multiple administrative commands that are important for when working with containers. These commands if you wish can be tested with the example container, or even better with multiple instances of it. Each and ever command shown may not be completely applicable however. </p>
<hr>
<h1 id="2-–-Administrative-Commands"><a href="#2-–-Administrative-Commands" class="headerlink" title="2 – Administrative Commands"></a>2 – Administrative Commands</h1><p>Here’s a list of select Docker commands to refer to when playing around with or monitoring containers. There are even more to check out as this list is by no means exhaustive.</p>
<p>A few core commands were already mentioned in <a href="http://www.tricksofthetrades.net/2015/12/23/installing-running-docker/">Docker - Installing and Running (1)</a>  so won’t appear here. </p>
<p>The first command allows you to <a href="https://docs.docker.com/engine/reference/commandline/attach/" target="_blank" rel="external">attach</a> to a running container interactively using the container’s ID or name:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach &lt;container-name&gt;</span><br></pre></td></tr></table></figure>
<p>You can detach again from the container and leave it running with <code>CTRL</code> + <code>P</code> or <code>CTRL</code> + <code>Q</code> for a quiet exit.</p>
<p>To list the changed files and directories in a container᾿s filesystem use <a href="https://docs.docker.com/engine/reference/commandline/diff/" target="_blank" rel="external">diff</a>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker diff &lt;container-name&gt;</span><br></pre></td></tr></table></figure>
<p>Where in the output the three “event types” are tagged as either:</p>
<ul>
<li><code>A</code> - Add</li>
<li><code>D</code> - Delete</li>
<li><code>C</code> - Change</li>
</ul>
<p>For real-time container and image activity begin a feed of <a href="https://docs.docker.com/engine/reference/commandline/events/" target="_blank" rel="external">event</a> output with:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker events</span><br></pre></td></tr></table></figure>
<p>The <a href="https://docs.docker.com/engine/reference/commandline/exec/" target="_blank" rel="external">exec</a> command runs a command of your choosing inside a container without dropping you down into a shell inside the container.</p>
<p>This example creates a container named <code>ubuntu_bash</code> and starts a Bash session that runs the <code>touch</code> command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> <span class="_">-d</span> ubuntu_bash touch /tmp/<span class="built_in">exec</span>Works</span><br></pre></td></tr></table></figure>
<p>Backing up a containers <strong>internal</strong> file-system as a tar archive is carried out using the “<a href="https://docs.docker.com/engine/reference/commandline/export/" target="_blank" rel="external">export</a>“ command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">export</span> &lt;container-name&gt; &gt; backup-archive.tar</span><br></pre></td></tr></table></figure>
<p>Show the internal <a href="https://docs.docker.com/engine/reference/commandline/history/" target="_blank" rel="external">history</a> of an image with human readable <code>-H</code> values:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> -H &lt;image-name&gt;</span><br></pre></td></tr></table></figure>
<p>To display system wide Docker <a href="https://docs.docker.com/engine/reference/commandline/info/" target="_blank" rel="external">info</a> and statistics use: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker -D info</span><br></pre></td></tr></table></figure>
<p>Return low-level information on a container or image using <a href="https://docs.docker.com/engine/reference/commandline/inspect/" target="_blank" rel="external">inspect</a>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect</span><br></pre></td></tr></table></figure>
<p>You can filter with the <code>inspect</code> command by adding the parameters described on the previously linked page.</p>
<p>Use <code>SIGKILL</code> to <a href="https://docs.docker.com/engine/reference/commandline/kill/" target="_blank" rel="external">kill</a> a running container, caution as usual is advised with this:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">kill</span> &lt;container-name&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.docker.com/engine/reference/commandline/pause/" target="_blank" rel="external">Pause</a> and <a href="https://docs.docker.com/engine/reference/commandline/unpause/" target="_blank" rel="external">unpause</a> all running processes in a Docker container:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pause</span><br><span class="line">$ docker unpause</span><br></pre></td></tr></table></figure>
<p>If the auto-generated names are not to your taste rename containers like this:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rename &lt;container-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure>
<p>Alternatively when first creating/running a container <code>--name</code> sets the name from the onset:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name &lt;container-name&gt; <span class="_">-d</span> &lt;image-name&gt;</span><br></pre></td></tr></table></figure>
<p>Enter a real-time live feed of one or more containers resource usage <a href="https://docs.docker.com/engine/reference/commandline/stats/" target="_blank" rel="external">stats</a>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stats &lt;container-name&gt;</span><br></pre></td></tr></table></figure>
<p>Docker has its own <a href="https://docs.docker.com/engine/reference/commandline/top/" target="_blank" rel="external">top</a> command for containers, to see the running processes inside:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker top &lt;container-name&gt;</span><br></pre></td></tr></table></figure>
<p>That’s all for these. Some real world examples of running images from the official Docker Hub repositories are now covered briefly to serve as realistic examples for how you might want to use Docker and its containerisation. </p>
<p>Be mindful that these are not walk-throughs on fully setting up each service, but general starting points for each.</p>
<hr>
<h1 id="3-–-Ghost-Image-Container"><a href="#3-–-Ghost-Image-Container" class="headerlink" title="3 – Ghost Image Container"></a>3 – Ghost Image Container</h1><blockquote>
<p><strong>“Ghost is a free and open source blogging platform written in JavaScript.”</strong></p>
</blockquote>
<p>To pull the image itself:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ghost</span><br></pre></td></tr></table></figure>
<p>To run a basic Ghost instance named <code>ghost-blog-name</code> on the mapped port <code>2368</code> use:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name &lt;container-name&gt; -p 8080:2368 <span class="_">-d</span> ghost</span><br></pre></td></tr></table></figure>
<p>Then access the blog via <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> or <a href="http://your.hosts.ip.address:8080" target="_blank" rel="external">http://your.hosts.ip.address:8080</a> in a browser.</p>
<p><img src="http://i.imgur.com/1umv5BN.png" alt="Ghost Default Blog Image"></p>
<p>The image can also be pointed to existing Ghost content on your local host:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name &lt;container-name&gt; -v /path/to/ghost/blog:/var/lib/ghost ghost</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://hub.docker.com/_/ghost/" target="_blank" rel="external">Docker Hub - Ghost</a></p>
</blockquote>
<hr>
<h1 id="4-–-irssi-Image-Container"><a href="#4-–-irssi-Image-Container" class="headerlink" title="4 – irssi Image Container"></a>4 – irssi Image Container</h1><blockquote>
<p><strong>“irssi is a terminal based IRC client for UNIX systems.”</strong></p>
</blockquote>
<p>I’m not sure about the benefits of running your irssi client through Docker but to serve as another example we’ll go through the Docker Hub provided setup process:</p>
<p>Create an interactive shell session in a new container named whatever you choose whilst setting an environment variable named <code>TERM</code> that is retrieved from the host. The user ID is set with <code>-u</code> and group ID is set with the <code>-g</code> option:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name &lt;container-name&gt; <span class="_">-e</span> TERM -u $(id -u):$(id -g) \</span><br></pre></td></tr></table></figure>
<p>Then stop the log driver to avoid storing “useless interactive terminal data”:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; --log-driver=none \</span><br></pre></td></tr></table></figure>
<p>Mount and bind the hosts <code>/.irssi</code> config home directory to the internal container equivalent: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; -v <span class="variable">$HOME</span>/.irssi:/home/user/.irssi:ro \</span><br></pre></td></tr></table></figure>
<p>Mount and bind the hosts <code>/localtime</code> directory to the internal container equivalent: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; -v /etc/localtime:/etc/localtime:ro \</span><br></pre></td></tr></table></figure>
<p>Pull down and apply all the previous commands to the <code>irssi</code> image from Docker Hub:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; irssi</span><br></pre></td></tr></table></figure>
<p>As everyone who uses irssi has their own configuration for the program this image does not come with any provided pre-sets. So you have to set this up yourself. Other than this you are dropped into the irssi session within the new container.</p>
<p><img src="http://i.imgur.com/phsQdD0.png" alt="irssi Containerised Image"></p>
<blockquote>
<p><a href="https://hub.docker.com/_/irssi/" target="_blank" rel="external">Docker Hub - irssi</a></p>
</blockquote>
<hr>
<h1 id="5-–-MongoDB-Image-Container"><a href="#5-–-MongoDB-Image-Container" class="headerlink" title="5 – MongoDB Image Container"></a>5 – MongoDB Image Container</h1><blockquote>
<p><strong>“MongoDB document databases provide high availability and easy scalability.”</strong></p>
</blockquote>
<p>The standard command to pull the image and container is one we’re familiar with by now:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name &lt;mongo-container-name&gt; <span class="_">-d</span> mongo</span><br></pre></td></tr></table></figure>
<p>This image is configured to expose port <strong>27017</strong> (Mongo’s default port), so linking other containers to it will make it automatically available. </p>
<p>In brief this is how to link a new container to a Mongo container named <code>mongo-container-name</code>. The image at the end is the application/service the new container will run:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name &lt;new-container-name&gt; --link &lt;mongo-container-name&gt;:mongo <span class="_">-d</span> &lt;image-name&gt;</span><br></pre></td></tr></table></figure>
<p>Using <code>inspect</code> with <code>grep</code> shows the link:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect nginx-container | grep -i -A1 <span class="string">"links"</span></span><br></pre></td></tr></table></figure>
<p>With the output in my case being:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Links"</span>: [</span><br><span class="line">            <span class="string">"/mongo-container:/nginx-container/mongo"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://hub.docker.com/_/mongo/" target="_blank" rel="external">Docker Hub - MongoDB</a></p>
</blockquote>
<hr>
<h1 id="6-–-NGINX-Image-Container"><a href="#6-–-NGINX-Image-Container" class="headerlink" title="6 – NGINX Image Container"></a>6 – NGINX Image Container</h1><blockquote>
<p><strong>“Nginx (pronounced “engine-x”) is an open source reverse proxy server for HTTP, HTTPS, SMTP, POP3, and IMAP protocols, as well as a load balancer, HTTP cache, and a web server (origin server).”</strong></p>
</blockquote>
<p>As usual like with all these images to download/pull:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx</span><br></pre></td></tr></table></figure>
<p>A basic example is given of some static HTML content served from a directory (<code>~/static-content-dir</code>) that has been mounted onto the NGINX hosting directory within the new container: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name &lt;container-name&gt; -v ~/static-content-dir:/usr/share/nginx/html:ro -P <span class="_">-d</span> nginx</span><br></pre></td></tr></table></figure>
<p>Whichever port is auto-assigned to the NGINX container can be used to access the static HTML content.</p>
<p>Find out the port number using either <code>docker ps</code> or:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker port &lt;container-name&gt;</span><br></pre></td></tr></table></figure>
<p>For our purpose here we want the second line’s port which in my case is <code>327773</code> - as shown:</p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">443/tcp -&gt; 0.0.0.0:32772</span><br><span class="line">80/tcp -&gt; 0.0.0.0:32773</span><br></pre></td></tr></table></figure>
<p><a href="http://localhost:32773" target="_blank" rel="external">http://localhost:32773</a> or <a href="http://your.hosts.ip.address:32773" target="_blank" rel="external">http://your.hosts.ip.address:32773</a> in a browser on the localhost now returns:</p>
<p><img src="http://i.imgur.com/eB7yWCi.png" alt="32773 Port Image"></p>
<p>The same idea but with a <code>Dockerfile</code> is better, one that is located in the directory containing our static HTML content: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/static-content-dir/Dockerfile</span><br></pre></td></tr></table></figure>
<p>Type in:</p>
<figure class="highlight bash"><figcaption><span>~/static-content-dir/Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">COPY . /usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<p>Then build a new image with the <code>Dockerfile</code> and give it a suitable name; <code>nginx-custom-image</code> is what I’m using for this example:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx-custom-image ~/static-content-dir/</span><br></pre></td></tr></table></figure>
<p>If this is successful output in this form is given:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon 6.372 MB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line"> ---&gt; 5328fdfe9b8e</span><br><span class="line">Step 2 : COPY . /usr/share/nginx/html</span><br><span class="line"> ---&gt; a4bf297e4dcc</span><br><span class="line">Removing intermediate container 7a213493723d</span><br><span class="line">Successfully built a4bf297e4dcc</span><br></pre></td></tr></table></figure>
<p>All that’s left is to run the custom built image, this time with a more typical, user provided port number:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name &lt;container-name&gt; -p 8080:80 <span class="_">-d</span> nginx-custom-image</span><br></pre></td></tr></table></figure>
<p>Again accessing <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> or <a href="http://your.hosts.ip.address:8080" target="_blank" rel="external">http://your.hosts.ip.address:8080</a> in a browser on the localhost shows the static HTML web pages:</p>
<p><img src="http://i.imgur.com/KOwae6N.png" alt="8080 Port Image"></p>
<blockquote>
<p><a href="https://hub.docker.com/_/nginx/" target="_blank" rel="external">Docker Hub - NGINX</a></p>
</blockquote>
<hr>
<h1 id="7-–-Apache-httpd-2-4-Image-Container"><a href="#7-–-Apache-httpd-2-4-Image-Container" class="headerlink" title="7 – Apache httpd (2.4) Image Container"></a>7 – Apache httpd (2.4) Image Container</h1><p>To serve static HTML content in a directory named <code>static-content-dir</code> on port <code>32775</code> of the local host machine we can use:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name &lt;container-name&gt; -v ~/static-content-dir:/usr/<span class="built_in">local</span>/apache2/htdocs/ -p 32755:80 <span class="_">-d</span> httpd:2.4</span><br></pre></td></tr></table></figure>
<p>Visiting <a href="http://localhost:32755" target="_blank" rel="external">http://localhost:32755</a> or <a href="http://your.hosts.ip.address:32755" target="_blank" rel="external">http://your.hosts.ip.address:32755</a> in a browser on the localhost then returns:</p>
<p><img src="http://i.imgur.com/2TuGYPe.png" alt="Port 32755 Image"></p>
<p>With a Dockerfile for configuration, custom setups can be applied. Create the <code>Dockerfile</code> in the project directory where the static content is hosted from:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/static-content-dir/Dockerfile</span><br></pre></td></tr></table></figure>
<p>Add lines like the below, where line 2 copies a httpd config file from the current working directory, to the internal container’s version. And line 3 copies the entirety of the current working directory (the static HTML files) to the Apache container’s web hosting directory:</p>
<figure class="highlight bash"><figcaption><span>~/static-content-dir/Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM httpd:2.4</span><br><span class="line">COPY ./my-httpd.conf /usr/<span class="built_in">local</span>/apache2/conf/httpd.conf</span><br><span class="line">COPY . /usr/<span class="built_in">local</span>/apache2/htdocs/</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong> If the <code>my-httpd:2.4</code> configuration file is missing, the next command to build the image will fail. </p>
</blockquote>
<p>Build the new custom Apache image defined in the <code>Dockerfile</code> and give it the name <code>custom-apache-image</code> which you can of course change if you like:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t custom-apache-image ~/static-content-dir/</span><br></pre></td></tr></table></figure>
<p>Successful output for the image build sequence looks like this (or similar): </p>
<figure class="highlight bash"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon 6.372 MB</span><br><span class="line">Step 1 : FROM httpd:2.4</span><br><span class="line"> ---&gt; 1a49ac676c05</span><br><span class="line">Step 2 : COPY . /usr/<span class="built_in">local</span>/apache2/htdocs/</span><br><span class="line"> ---&gt; f7052ffe8190</span><br><span class="line">Removing intermediate container 53311d3ac0a5</span><br><span class="line">Successfully built f7052ffe8190</span><br></pre></td></tr></table></figure>
<p>Lastly, start and run a new container using the custom generated image on port <code>32756</code> of the localhost machine:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name &lt;container-name&gt; -p 32756:80 <span class="_">-d</span> custom-apache-image</span><br></pre></td></tr></table></figure>
<p>Visiting <a href="http://localhost:32756" target="_blank" rel="external">http://localhost:32756</a> or <a href="http://your.hosts.ip.address:32756" target="_blank" rel="external">http://your.hosts.ip.address:32756</a> in a browser on the localhost now returns:</p>
<p><img src="http://i.imgur.com/92R7BYV.png" alt="Port 32756 Image"></p>
<blockquote>
<p><a href="https://hub.docker.com/_/httpd/" target="_blank" rel="external">Docker Hub - httpd</a></p>
</blockquote>
<hr>
<h1 id="8-–-Jenkins-Image-Container"><a href="#8-–-Jenkins-Image-Container" class="headerlink" title="8 – Jenkins Image Container"></a>8 – Jenkins Image Container</h1><p>Create a new directory in your user’s home directory for the Jenkins config files. This will be mounted and mapped to the container’s equivalent configuration space: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/jenkins_home</span><br></pre></td></tr></table></figure>
<p>Run the Jenkins image mapping the two internal ports to ephermal ports on the host side, whilst syncing the config directory we just created to the new container:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name &lt;container-name&gt; -p 32790:8080 -p 32791:50000 -v ~/jenkins_home:/var/jenkins_home <span class="_">-d</span> jenkins</span><br></pre></td></tr></table></figure>
<p>Jenkins can be seen at the first port number we mapped. In my example it was  <code>32790</code> meaning a URL of  <a href="http://localhost:32790" target="_blank" rel="external">http://localhost:32790</a> or <a href="http://your.hosts.ip.address:32790" target="_blank" rel="external">http://your.hosts.ip.address:32790</a> in a browser takes us to the Jenkins application page:</p>
<p><img src="http://i.imgur.com/KMy5xOK.png" alt="Jenkins on Port 32790"></p>
<blockquote>
<p><a href="https://hub.docker.com/_/jenkins/" target="_blank" rel="external">Docker Hub - Jenkins</a></p>
</blockquote>
<hr>
<p>Remember that there are unofficial image repositories to be found on Docker Hub too, and potentially elsewhere when made available. </p>
<p>The third post on Docker talks a bit more about administration with Docker. As well as details based around how to network containers together. </p>
<p><a href="http://www.tricksofthetrades.net/trades/">Links to subsequent Docker posts can be found on the Trades page.</a></p>
<p><strong>More Information</strong></p>
<ul>
<li><a href="https://docs.docker.com/engine/userguide/usingdocker/" target="_blank" rel="external">Docker Docs - Run a Simple Application</a> – This is where the example of the Python program containerised comes from.  </li>
<li><a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="external">Docker Docs - Use the Docker Command Line</a> – The administrative commands in their entirety are found here on the left of the page. </li>
</ul>
<blockquote>
<p>Easily deploy an SSD cloud server on <a href="https://www.digitalocean.com/?refcode=e91058dbfc7b" target="_blank" rel="external">Digital Ocean</a> in 55 seconds. Sign up using my link and receive $10.00 in free credit: <a href="https://www.digitalocean.com/?refcode=e91058dbfc7b" target="_blank" rel="external">https://www.digitalocean.com/?refcode=e91058dbfc7b</a></p>
</blockquote>
<p>– Scarlz: <a href="https://twitter.com/5car1z" target="_blank" rel="external">@5car1z</a></p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/Docker/" class="post__tag__link">Docker</a></li><li class="post__tag__item"><a href="/tags/Virtualisation/" class="post__tag__link">Virtualisation</a></li><li class="post__tag__item"><a href="/tags/Containers/" class="post__tag__link">Containers</a></li></ul><a href="/2016/01/07/docker-administration-applications/#disqus_thread" class="post__foot-link u-fr">COMMENTS</a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2017 Scarlz</div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><a title="Next" href="/tags/Virtualisation/page/2/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","totts","count");
</script></body></html>